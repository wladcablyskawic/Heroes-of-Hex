// Generated by CoffeeScript 1.10.0
var indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

define(['jquery', 'external/underscore', 'external/react', "modules/constants/python", 'modules/core/i18n', 'modules/core/notify', 'modules/clean/account/email', 'modules/clean/account/email_verify_reasons', 'modules/clean/activity/activity', 'modules/clean/activity/activity_store', 'modules/clean/activity/activity_local_storage', 'modules/clean/activity/activity_user', 'modules/clean/activity/file_activity_cache', 'modules/clean/activity/file_viewer_state', 'modules/clean/analytics', 'modules/clean/annotations/annotation', 'modules/clean/base64', 'modules/clean/bolt', 'modules/clean/file_events', 'modules/clean/file_viewer_interface_controller', 'modules/clean/gandalf_util', 'modules/clean/keycode', 'modules/clean/react/modal', 'modules/clean/react/react_i18n', 'modules/clean/react/sprite', 'modules/clean/storage', 'modules/clean/viewer', 'modules/clean/react/file_comments/annotation_bubble', 'modules/clean/react/file_comments/annotation_comments_list_ui_bubble', 'modules/clean/react/file_comments/comment_list_ui', 'modules/clean/react/file_comments/file_feedback_likes_section', 'modules/clean/react/file_comments/logger', 'modules/clean/react/file_comments/shared_link_signup_modals', 'modules/clean/react/file_comments/switch_revision_ui', 'modules/clean/react/file_comments/onboarding', 'modules/clean/web_timing_logger'], function($j, $u, React, PythonConstants, arg, Notify, arg1, EmailVerificationReasons, Activity, ActivityStore, ActivityLocalStorage, ActivityUser, FileActivityCache, arg2, arg3, arg4, base64, Bolt, FileEvents, FileViewerInterfaceController, GandalfUtil, KeyCode, arg5, ReactI18n, SpriteClass, storage, Viewer, AnnotationBubbleClass, AnnotationCommentsListUIBubbleClass, CommentListUIClass, FileFeedbackLikesSectionClass, FileActivityClientLogger, CommentsSharedLinkSignupModals, SwitchRevisionUI, CommentingOnboardingModalClass, WebTimingLogger) {
  var ANNOTATION_BUBBLE_ARROW_SIZE, ANNOTATION_BUBBLE_HEIGHT, ANNOTATION_BUBBLE_VERTICAL_BUFFER, ANNOTATION_BUBBLE_WIDTH, ANNOTATION_COMMENTS_LIST_UI_OVERLAY_ID, ANNOTATION_OVERLAY_ID, AUTORESIZE_DEBOUNCE, ActivityContext, Annotation, AnnotationBubble, AnnotationCommentsListUIBubble, AnnotationSubtypes, AnnotationTypes, COMMENT_KEY_SCOPE, CommentListUI, CommentingOnboardingModal, ContactSearchLogger, EmailVerification, FEEDBACK_HEIGHT, FV_TITLE_BAR_SELECTOR, FileActivity, FileActivityStore, FileFeedbackLikesSection, FileFeedbackUIClass, FileViewerState, LIKES_SECTION_HEIGHT, Modal, OFFLINE_BANNER_HEIGHT, OFFLINE_CHECK_INTERVAL, R_, SWITCH_REVISION_CONTAINER_ID, SimpleModal, Sprite, _, d;
  _ = arg._;
  EmailVerification = arg1.EmailVerification;
  FileViewerState = arg2.FileViewerState;
  ContactSearchLogger = arg3.ContactSearchLogger;
  Annotation = arg4.Annotation, AnnotationTypes = arg4.AnnotationTypes, AnnotationSubtypes = arg4.AnnotationSubtypes;
  SimpleModal = arg5.SimpleModal, Modal = arg5.Modal;
  d = React.DOM;
  R_ = ReactI18n.R_;
  AnnotationBubble = React.createFactory(AnnotationBubbleClass);
  AnnotationCommentsListUIBubble = React.createFactory(AnnotationCommentsListUIBubbleClass);
  CommentListUI = React.createFactory(CommentListUIClass);
  FileFeedbackLikesSection = React.createFactory(FileFeedbackLikesSectionClass);
  Sprite = React.createFactory(SpriteClass);
  CommentingOnboardingModal = React.createFactory(CommentingOnboardingModalClass);
  COMMENT_KEY_SCOPE = "comment";
  ActivityContext = Activity.ActivityContext;
  FileActivity = Activity.FileActivity;
  FileActivityStore = ActivityStore.FileActivityStore;
  OFFLINE_CHECK_INTERVAL = 1000;
  LIKES_SECTION_HEIGHT = 50;
  FEEDBACK_HEIGHT = 50;
  OFFLINE_BANNER_HEIGHT = 50;
  ANNOTATION_BUBBLE_HEIGHT = 120;
  ANNOTATION_BUBBLE_WIDTH = 320;
  ANNOTATION_BUBBLE_ARROW_SIZE = 10;
  ANNOTATION_BUBBLE_VERTICAL_BUFFER = 11;
  AUTORESIZE_DEBOUNCE = 20;
  SWITCH_REVISION_CONTAINER_ID = "switch-revision-container";
  ANNOTATION_OVERLAY_ID = "annotation-overlay";
  ANNOTATION_COMMENTS_LIST_UI_OVERLAY_ID = "annotation-comments-list-ui-overlay";
  FV_TITLE_BAR_SELECTOR = '.react-file-viewer__title-bar';
  FileFeedbackUIClass = React.createClass({
    displayName: "FileFeedbackUI",
    propTypes: {
      visible: React.PropTypes.bool.isRequired,
      showButtonColor: React.PropTypes.string.isRequired,
      activityCache: React.PropTypes.instanceOf(FileActivityCache),
      activityContext: React.PropTypes.number,
      activityContextData: React.PropTypes.string,
      onActivityLoaded: React.PropTypes.func,
      hideToggledCallback: React.PropTypes.func,
      photoLikesVariant: React.PropTypes.string,
      photoSocialShareVariant: React.PropTypes.string,
      previewWidthCallback: React.PropTypes.func,
      feedbackId: React.PropTypes.string.isRequired,
      onInputFocus: React.PropTypes.func,
      onInputBlur: React.PropTypes.func,
      userId: React.PropTypes.number,
      showDisabledCommentBar: React.PropTypes.bool,
      previewSelector: React.PropTypes.string,
      forceNullStateLoadingState: React.PropTypes.bool,
      shouldInitiallyFocusInput: React.PropTypes.bool,
      canCollapse: React.PropTypes.bool,
      shouldAutoLinkify: React.PropTypes.bool,
      shouldAutoResize: React.PropTypes.bool,
      enableImport: React.PropTypes.bool,
      shouldUseSimpleModals: React.PropTypes.bool,
      shouldHidePhotoAvatars: React.PropTypes.bool,
      file: React.PropTypes.object,
      previewType: React.PropTypes.string,
      oref: React.PropTypes.string,
      switchPreview: React.PropTypes.func,
      shouldCheckOffline: React.PropTypes.bool,
      shouldShowOnboarding: React.PropTypes.bool,
      onOnboardingModalOpen: React.PropTypes.func,
      shouldAnnotationButtonUseThumbnailUrls: React.PropTypes.bool
    },
    getInitialState: function() {
      this._previewLoadedCallback = $j.noop;
      this.previewIsReady = false;
      return {
        visible: this.props.visible,
        enabled: true,
        height: 0,
        comments_on: true,
        icon: "s_comments_locked",
        contextActivityStore: new FileActivityStore(this.props.activityContext, this.props.activityContextData),
        started_fetching_activity: false,
        isNewCommentLoading: false,
        showResolvedComments: false,
        isCommentInputDisabled: false,
        isOffline: false
      };
    },
    getDefaultProps: function() {
      return {
        photoLikesVariant: "CONTROL",
        photoSocialShareVariant: "CONTROL",
        forceNullStateLoadingState: false,
        canCollapse: true,
        shouldAutoLinkify: true,
        enableImport: true,
        onActivityLoaded: $j.noop,
        shouldAutoResize: false,
        shouldUseSimpleModals: false,
        shouldHidePhotoAvatars: false,
        switchPreview: $j.noop,
        file: null,
        shouldCheckOffline: false,
        shouldShowOnboarding: false,
        shouldAnnotationButtonUseThumbnailUrls: GandalfUtil.getGandalfRule("dw-comments-annotation-thumbnails")
      };
    },
    componentWillMount: function() {
      var activity, ref;
      this.isFluxEnabled = GandalfUtil.getGandalfRule("comments-flux");
      this.isAnnotationCreationEnabled = GandalfUtil.getGandalfRule("dw-comments-annotation-marker") || GandalfUtil.getGandalfRule("dw-comments-annotation-highlight") || GandalfUtil.getGandalfRule("dw-comments-annotation-region");
      this.isAnnotationGhostEnabled = GandalfUtil.getGandalfRule("dw-comments-annotation-ghost");
      this.isThreadingEnabled = GandalfUtil.getGandalfRule("dw-comments-threading");
      this.isTinyAnnotationUIEnabled = GandalfUtil.getGandalfRule("dw-comments-tiny-annotation-ui");
      this.isImagePreviewAnnotationEnabled = GandalfUtil.getGandalfRule("dw-comments-annotation-image-previews");
      this.shouldShowAnnotationUIOnImages = this.isImagePreviewAnnotationEnabled || GandalfUtil.getGandalfRule('comments-image-previews-annotations-visible');
      if (!this.getActivityUser().is_signed_in) {
        this.modals = new CommentsSharedLinkSignupModals();
      }
      if (this.props.activityContext && this.props.activityContextData) {
        this._prepareFileViewerState(this.props.file, this.props.activityContextData, this.props.previewType);
        this._prepareFileViewerInterfaceController(this.props.activityContext);
        activity = (ref = this.props.activityCache) != null ? ref.getActivity(this.props.activityContext, this.props.activityContextData) : void 0;
        if (activity != null) {
          return this._onActivitySuccessfullyFetched(activity);
        }
      }
    },
    componentWillReceiveProps: function(nextProps) {
      var activity, ref;
      if (this.props.activityContextData !== nextProps.activityContextData) {
        this._reset();
        this.setState({
          contextActivityStore: new FileActivityStore(nextProps.activityContext, nextProps.activityContextData)
        });
        this._prepareFileViewerState(nextProps.file, nextProps.activityContextData, nextProps.previewType);
        this._prepareFileViewerInterfaceController(nextProps.activityContextData);
        activity = (ref = this.props.activityCache) != null ? ref.getActivity(nextProps.activityContext, nextProps.activityContextData) : void 0;
        if (activity != null) {
          return this._onActivitySuccessfullyFetched(activity);
        }
      }
    },
    componentDidMount: function() {
      this._refreshWidth();
      if (this.props.shouldAutoResize) {
        this.autoResize();
      }
      this.contactSearchLogger = new ContactSearchLogger();
      if (this.props.shouldCheckOffline) {
        this._checkAndSetIsOffline();
        this.offlineInterval = setInterval(this._checkAndSetIsOffline, OFFLINE_CHECK_INTERVAL);
      }
      if (this.props.shouldAutoResize) {
        this._debouncedAutoResize = $u.debounce(this.autoResize, AUTORESIZE_DEBOUNCE);
        $j(window).on('resize', this._debouncedAutoResize);
      }
      if (this._shouldFetchActivity()) {
        return this._fetchActivity(this.maybeShowOnboardingModal);
      }
    },
    componentDidUpdate: function(prevProps, prevState) {
      var activity, didActivityChange, didCommentsPaneChange, didResolvedCommentsVisibilityChange, ref, ref1;
      if (this.props.activityContextData !== prevProps.activityContextData) {
        if (this._shouldFetchActivity() && (this.props.activityCache != null)) {
          activity = this.props.activityCache.getActivity(this.props.activityContext, this.props.activityContextData);
          if (activity != null) {
            this._onActivitySuccessfullyFetched(activity);
          }
        }
        if (this._shouldFetchActivity()) {
          this._fetchActivity();
        }
      }
      didActivityChange = this.state.activity !== prevState.activity;
      if (didActivityChange) {
        this.notifyActivityLoaded(this.state.activity);
        this.removeAllAnnotations();
        this.redrawAllAnnotations();
        if (this.props.activityCache != null) {
          this.props.activityCache.setActivity(this.props.activityContext, this.props.activityContextData, this.state.activity);
        }
      }
      didResolvedCommentsVisibilityChange = this.state.showResolvedComments !== prevState.showResolvedComments;
      if (didResolvedCommentsVisibilityChange) {
        if (!this.state.showResolvedComments) {
          this.removeAllAnnotations();
        }
        this.redrawAllAnnotations();
      }
      didCommentsPaneChange = this.state.comments_on !== prevState.comments_on || this.state.visible !== prevState.visible || this.state.enabled !== prevState.enabled || ((ref = this.state.activity) != null ? ref.feedback_off : void 0) !== ((ref1 = prevState.activity) != null ? ref1.feedback_off : void 0);
      if (didCommentsPaneChange) {
        this._refreshWidth();
        if (this._isCommentsOnAndVisible()) {
          this.enableAnnotationCreation();
          return this.redrawAllAnnotations();
        } else {
          this.removeAllAnnotations();
          this.disableAnnotationCreation();
          this.hideAnnotationBubble();
          return this.hideAnnotationCommentsBubble();
        }
      }
    },
    componentWillUnmount: function() {
      return this._reset();
    },
    close: function() {
      this.onSwitchToLatestRevision();
      return this._reset();
    },
    notifyActivityLoaded: function(activity) {
      var base;
      if (typeof (base = this.props).onActivityLoaded === "function") {
        base.onActivityLoaded(activity);
      }
      if (this.props.shouldAutoResize) {
        return this.autoResize();
      }
    },
    autoResize: function() {
      var height;
      height = $j(window).height() - $j(FV_TITLE_BAR_SELECTOR).height();
      return this.fitToHeight(height);
    },
    onPreviewAndCommentsReady: function() {
      var ref;
      $j((ref = this.refs.fileFeedbackUI) != null ? ref.getDOMNode() : void 0).addClass("preview-ready");
      this._prepareAnnotationAndCommentsBubble();
      if (this._isCommentsOnAndVisible()) {
        this.enableAnnotationCreation();
        return this.redrawAllAnnotations();
      }
    },
    maybeShowOnboardingModal: function() {
      var onboardingModal;
      if (this.props.shouldShowOnboarding) {
        onboardingModal = CommentingOnboardingModal({
          onOpen: this.props.onOnboardingModalOpen
        });
        return Modal.showInstance(onboardingModal);
      }
    },
    _reset: function() {
      var ref;
      this.disableAnnotationCreation();
      this.previewIsReady = false;
      React.unmountComponentAtNode(this.$annotationOverlayContainer);
      React.unmountComponentAtNode(this.$annotationCommentsListUIOverlayContainer);
      this.annotationBubble = null;
      this.annotationCommentsListUIBubble = null;
      if (this.props.shouldCheckOffline) {
        clearInterval(this.offlineInterval);
      }
      this.removeAllAnnotations();
      this.hideAnnotationBubble();
      this.hideAnnotationCommentsBubble();
      this._stopLiveUpdate();
      if ((ref = this.fileViewerInterfaceController) != null) {
        ref.destroy();
      }
      if (this._debouncedAutoResize != null) {
        return $j(window).off('resize', this._debouncedAutoResize);
      }
    },
    _prepareFileViewerState: function(file, activityContextData, previewType) {
      return this.fileViewerState = new FileViewerState(file, activityContextData, previewType);
    },
    _prepareFileViewerInterfaceController: function(activityContext) {
      var previewType, ref, viewerType;
      if ((ref = this.fileViewerInterfaceController) != null) {
        ref.destroy();
      }
      viewerType = activityContext;
      previewType = this.fileViewerState.getPreviewType(viewerType);
      this.fileViewerInterfaceController = new FileViewerInterfaceController(viewerType, previewType);
      this.fileViewerInterfaceController.registerEventsCallbacks(this.onAnnotationEventsCallback);
      return this.fileViewerInterfaceController.dispatchEvent("file-feedback-ui-ready");
    },
    _previewLoaded: function() {
      if (this._previewLoadedCallback) {
        this._previewLoadedCallback();
        return this._previewLoadedCallback = $j.noop;
      }
    },
    _isCommentsOnAndVisible: function() {
      return this.state.comments_on && this.state.visible && this.state.enabled && (this.state.activity != null) && !this.state.activity.feedback_off;
    },
    _isAnnotationCreationEnabled: function() {
      return this.isAnnotationCreationEnabled && this._isCommentsOnAndVisible();
    },
    _isPreviewAndCommentsReady: function() {
      return this.state.enabled && (this.state.activity != null) && this.previewIsReady && !this.state.isFetchingActivity;
    },
    _fileHasReplies: function() {
      var ca, i, len, ref;
      if (this.state.activity != null) {
        ref = this.state.activity.comment_activities;
        for (i = 0, len = ref.length; i < len; i++) {
          ca = ref[i];
          if (ca.comment_activities.length > 0) {
            return true;
          }
        }
      }
      return false;
    },
    _isThreadingEnabled: function() {
      return this.isThreadingEnabled || this._fileHasReplies();
    },
    _checkAndSetIsOffline: function() {
      return this.setState({
        isOffline: !navigator.onLine
      });
    },
    _prepareSwitchRevisionUI: function() {
      var safeEl;
      if (this.props.previewSelector != null) {
        if (!$j("#" + SWITCH_REVISION_CONTAINER_ID).length) {
          safeEl = $j("<div />", {
            id: "" + SWITCH_REVISION_CONTAINER_ID
          });
          $j("body").append(safeEl);
        }
        this.$switchRevisionUIContainer = $j("#" + SWITCH_REVISION_CONTAINER_ID).get(0);
        return this.switchRevisionUI = React.render(React.createElement(SwitchRevisionUI, {
          showSwitchRevisionUI: false,
          onSwitchToLatestRevision: this.onSwitchToLatestRevision
        }), this.$switchRevisionUIContainer);
      }
    },
    _prepareAnnotationContainers: function() {
      var safeAnnotationCommentsListUIOverlayEl, safeAnnotationOverlayEl;
      if (this.props.previewSelector != null) {
        this.$previewContainer = $j(this.props.previewSelector);
        if (this.$previewContainer.length) {
          if (this.isAnnotationCreationEnabled && !this.annotationBubble && this.fileViewerState.isCurrentlyAtLatestRevision()) {
            if (!$j("#" + ANNOTATION_OVERLAY_ID).length) {
              safeAnnotationOverlayEl = $j("<div />", {
                id: "" + ANNOTATION_OVERLAY_ID
              });
              this.$previewContainer.append(safeAnnotationOverlayEl);
            }
            this.$annotationOverlayContainer = $j("#" + ANNOTATION_OVERLAY_ID).get(0);
            this.annotationBubble = React.render(AnnotationBubble({
              showBubble: false,
              onAddComment: this.onAddCommentFromAnnotationBubble,
              onCancelComment: this.onCancelCommentFromAnnotationBubble
            }), this.$annotationOverlayContainer);
          }
          if (!this.annotationCommentsListUIBubble) {
            if (!$j("#" + ANNOTATION_COMMENTS_LIST_UI_OVERLAY_ID).length) {
              safeAnnotationCommentsListUIOverlayEl = $j("<div />", {
                id: "" + ANNOTATION_COMMENTS_LIST_UI_OVERLAY_ID
              });
              this.$previewContainer.append(safeAnnotationCommentsListUIOverlayEl);
            }
            this.$annotationCommentsListUIOverlayContainer = $j("#" + ANNOTATION_COMMENTS_LIST_UI_OVERLAY_ID).get(0);
            return this.annotationCommentsListUIBubble = React.render(AnnotationCommentsListUIBubble({
              fileViewerInterfaceController: this.fileViewerInterfaceController,
              fileViewerState: this.fileViewerState,
              showBubble: false,
              isThreadingEnabled: this._isThreadingEnabled(),
              onDeleteComment: this.onDeleteCommentFromAnnotationBubble,
              onLikeComment: this.onLikeCommentFromAnnotationBubble,
              onMouseLeave: this.onAnnotationCommentsListUIBubbleMouseLeave,
              onMouseOver: this.onAnnotationCommentsListUIBubbleMouseOver,
              onUpdateResolve: this.onResolveCommentFromAnnotationBubble,
              onAddCommentFromList: this.onAddCommentFromList,
              onAddSticker: this.onAddCommentFromSticker
            }), this.$annotationCommentsListUIOverlayContainer);
          }
        }
      }
    },
    highlightComment: function(data) {
      var $comment, $commentList, activityKey, commentActivity;
      if (data.commentActivity != null) {
        commentActivity = data.commentActivity;
        activityKey = commentActivity.activity_key;
        $comment = $j(".comments-and-feedback .comment-activity[data-comment-activity-key='" + activityKey + "']").get(0);
        if ($comment != null) {
          $comment.classList.remove("start-highlight-animation");
          $comment.offsetWidth = $comment.offsetWidth;
          $comment.classList.add("start-highlight-animation");
          $commentList = $j(".comment-list");
          return $commentList.animate({
            scrollTop: $comment.offsetTop
          }, {
            duration: 500
          });
        }
      }
    },
    hideAnnotationCommentsBubble: function() {
      var ref;
      return (ref = this.annotationCommentsListUIBubble) != null ? ref.setProps({
        showBubble: false
      }) : void 0;
    },
    showAnnotationCommentsBubble: function(data) {
      var annotation, bubbleDirection, bubblePosition, ca, commentActivity, i, len, ref, ref1, results;
      clearTimeout(this.annotationCommentsListUIBubbleTimer);
      if (data.annotation != null) {
        annotation = Annotation.createAnnotationFromDict(data.annotation);
        commentActivity = data.commentActivity;
        if (this.annotationCommentsListUIBubble) {
          ref = this.state.activity.comment_activities;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            ca = ref[i];
            if (ca.activity_key === commentActivity.activity_key) {
              if (!this._isBoundingBoxOffscreen(annotation)) {
                ref1 = this._getBubbleLocation(annotation), bubbleDirection = ref1[0], bubblePosition = ref1[1];
                if (bubbleDirection != null) {
                  results.push(this.annotationCommentsListUIBubble.setProps({
                    annotation: annotation,
                    commentActivity: ca,
                    contextActivityStore: this.state.contextActivityStore,
                    showBubble: true,
                    x: bubblePosition.x,
                    y: bubblePosition.y,
                    position: bubbleDirection
                  }));
                } else {
                  results.push(void 0);
                }
              } else {
                results.push(void 0);
              }
            } else {
              results.push(void 0);
            }
          }
          return results;
        }
      }
    },
    onAnnotationCommentsListUIBubbleMouseOver: function(annotation) {
      return clearTimeout(this.annotationCommentsListUIBubbleTimer);
    },
    onAnnotationCommentsListUIBubbleMouseLeave: function(annotation) {
      return this.hideAnnotationCommentsBubble();
    },
    hideAnnotation: function() {
      if (this.fileViewerInterfaceController) {
        return this.fileViewerInterfaceController.dispatchEvent("hide-annotation");
      }
    },
    hideAnnotationBubble: function() {
      var ref;
      return (ref = this.annotationBubble) != null ? ref.setProps({
        showBubble: false
      }) : void 0;
    },
    placeAnnotationBubble: function(data) {
      var annotation, bubbleDirection, bubblePosition, ref;
      if (this._isAnnotationCreationEnabled() && (data.annotation != null)) {
        if (this.annotationBubble) {
          annotation = Annotation.createAnnotationFromDict(data.annotation);
          if (!this._isBoundingBoxOffscreen(annotation)) {
            ref = this._getBubbleLocation(annotation), bubbleDirection = ref[0], bubblePosition = ref[1];
            if (bubbleDirection != null) {
              return this.annotationBubble.setProps({
                annotation: annotation,
                showBubble: true,
                x: bubblePosition.x,
                y: bubblePosition.y,
                position: bubbleDirection
              });
            }
          } else {
            return this.hideAnnotationBubble();
          }
        }
      }
    },
    _prepareAnnotationAndCommentsBubble: function() {
      var ref, ref1;
      this._prepareAnnotationContainers();
      if (this.state.contextActivityStore != null) {
        if ((ref = this.annotationBubble) != null) {
          ref.setProps({
            user: this.getActivityUser(),
            contextActivityStore: this.state.contextActivityStore,
            activity: this.state.activity
          });
        }
        return (ref1 = this.annotationCommentsListUIBubble) != null ? ref1.setProps({
          user: this.getActivityUser(),
          contextActivityStore: this.state.contextActivityStore,
          activity: this.state.activity
        }) : void 0;
      }
    },
    _getBubbleLocation: function(annotation) {
      var bubbleX, bubbleY, center, clampedBoundingBox, doesBubbleFitOnScreen, offsetX, offsetY, viewportHeight, viewportWidth;
      doesBubbleFitOnScreen = function(left, top, width, height) {
        return left >= 0 && left < width - ANNOTATION_BUBBLE_WIDTH && top >= 0 && top < height - ANNOTATION_BUBBLE_HEIGHT;
      };
      viewportWidth = this.$previewContainer.width();
      viewportHeight = this.$previewContainer.height();
      offsetX = annotation.isImageAnnotation() ? this.$previewContainer.offset().left : 0;
      offsetY = annotation.isImageAnnotation() ? this.$previewContainer.offset().top : 0;
      clampedBoundingBox = annotation.getClampedBoundingBox(viewportWidth, viewportHeight);
      clampedBoundingBox.left = clampedBoundingBox.left - offsetX;
      clampedBoundingBox.right = clampedBoundingBox.right - offsetX;
      clampedBoundingBox.top = clampedBoundingBox.top - offsetY;
      clampedBoundingBox.bottom = clampedBoundingBox.bottom - offsetY;
      center = Annotation.getCenterPosition(clampedBoundingBox);
      bubbleX = center.x - ANNOTATION_BUBBLE_WIDTH / 2;
      bubbleY = clampedBoundingBox.bottom + ANNOTATION_BUBBLE_ARROW_SIZE;
      if (doesBubbleFitOnScreen(bubbleX, bubbleY, viewportWidth, viewportHeight)) {
        return [
          "top", {
            x: bubbleX,
            y: bubbleY
          }
        ];
      }
      bubbleX = clampedBoundingBox.left - ANNOTATION_BUBBLE_WIDTH - ANNOTATION_BUBBLE_ARROW_SIZE;
      bubbleY = clampedBoundingBox.top - ANNOTATION_BUBBLE_VERTICAL_BUFFER;
      if (doesBubbleFitOnScreen(bubbleX, bubbleY, viewportWidth, viewportHeight)) {
        return [
          "right-top", {
            x: bubbleX,
            y: bubbleY
          }
        ];
      }
      bubbleX = clampedBoundingBox.right + ANNOTATION_BUBBLE_ARROW_SIZE;
      bubbleY = clampedBoundingBox.top - ANNOTATION_BUBBLE_VERTICAL_BUFFER;
      if (doesBubbleFitOnScreen(bubbleX, bubbleY, viewportWidth, viewportHeight)) {
        return [
          "left-top", {
            x: bubbleX,
            y: bubbleY
          }
        ];
      }
      bubbleX = center.x - ANNOTATION_BUBBLE_WIDTH / 2;
      bubbleY = clampedBoundingBox.top - ANNOTATION_BUBBLE_HEIGHT - ANNOTATION_BUBBLE_ARROW_SIZE;
      if (doesBubbleFitOnScreen(bubbleX, bubbleY, viewportWidth, viewportHeight)) {
        return [
          "bottom", {
            x: bubbleX,
            y: bubbleY
          }
        ];
      }
      bubbleX = center.x - ANNOTATION_BUBBLE_WIDTH / 2;
      bubbleY = center.y + ANNOTATION_BUBBLE_ARROW_SIZE;
      if (doesBubbleFitOnScreen(bubbleX, bubbleY, viewportWidth, viewportHeight)) {
        return [
          "top", {
            x: bubbleX,
            y: bubbleY
          }
        ];
      }
      return [null, null];
    },
    _isBoundingBoxOffscreen: function(annotation) {
      var boundingBox, overlayHeight, overlayWidth;
      overlayWidth = this.$previewContainer.width();
      overlayHeight = this.$previewContainer.height();
      boundingBox = annotation.getBoundingBox();
      return boundingBox.top >= overlayHeight || boundingBox.left >= overlayWidth || boundingBox.right < 0 || boundingBox.bottom < 0;
    },
    disableAnnotationCreation: function() {
      if (this.fileViewerInterfaceController) {
        return this.fileViewerInterfaceController.dispatchEvent("disable-annotation-creation");
      }
    },
    enableAnnotationCreation: function() {
      if (this.fileViewerInterfaceController && this.fileViewerState.isCurrentlyAtLatestRevision() && (this.annotationBubble != null)) {
        return this.fileViewerInterfaceController.dispatchEvent("enable-annotation-creation");
      }
    },
    removeAllAnnotations: function() {
      if (this.fileViewerInterfaceController) {
        return this.fileViewerInterfaceController.dispatchEvent("remove-all-annotations");
      }
    },
    redrawAnnotation: function(data) {
      if (this.fileViewerInterfaceController && this._isCommentsOnAndVisible()) {
        return this.fileViewerInterfaceController.dispatchEvent("draw-annotation", data);
      }
    },
    redrawAllAnnotations: function(page) {
      var annotation, commentActivity, i, len, options, ref, results, revision;
      if (page == null) {
        page = null;
      }
      if (this.state.activity && this.previewIsReady && this._isCommentsOnAndVisible()) {
        ref = this.state.activity.comment_activities;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          commentActivity = ref[i];
          options = {};
          if ((this.state.showResolvedComments || !commentActivity.comment.resolved) && commentActivity.comment.has_metadata() && commentActivity.comment.comment_metadata.has_annotation_data()) {
            revision = commentActivity.comment.comment_metadata.revision;
            if (this.isAnnotationGhostEnabled || ((revision != null) && this.fileViewerState.isCurrentlyAtRevision(revision))) {
              if (this.isAnnotationGhostEnabled && (revision != null) && !this.fileViewerState.isCurrentlyAtRevision(revision)) {
                options.isGhostAnnotation = true;
              }
              annotation = Annotation.createAnnotationFromDict(commentActivity.comment.comment_metadata.annotation);
              if (((page != null) && annotation.getFirstPdfPage() === page) || (page == null)) {
                results.push(this.redrawAnnotation({
                  annotation: commentActivity.comment.comment_metadata.annotation,
                  commentActivity: commentActivity,
                  options: options
                }));
              } else {
                results.push(void 0);
              }
            } else {
              results.push(void 0);
            }
          } else {
            results.push(void 0);
          }
        }
        return results;
      }
    },
    onAnnotationEventsCallback: function(eventName, data) {
      var commentActivity, commentMetadata, commentRevision, keyPressed, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7;
      switch (eventName) {
        case "annotation-hidden":
          this.hideAnnotationBubble();
          return FileActivityClientLogger.log_annotation_event(Constants.FILE_ACTIVITY_LOG_EVENT_TYPE.CLIENT_ANNOTATION_HIDDEN, this.state.activity.activity_key, null, this.getActivityUser().id, this.props.activityContext);
        case "annotation-placed":
          this.hideAnnotationCommentsBubble();
          this.placeAnnotationBubble(data);
          return FileActivityClientLogger.log_annotation_event(Constants.FILE_ACTIVITY_LOG_EVENT_TYPE.CLIENT_ANNOTATION_PLACED, this.state.activity.activity_key, null, this.getActivityUser().id, this.props.activityContext, data.annotation != null ? data.annotation : void 0);
        case "annotation-start-drag":
          return this.hideAnnotationBubble();
        case "annotation-end-drag":
          this.placeAnnotationBubble(data);
          return FileActivityClientLogger.log_annotation_event(Constants.FILE_ACTIVITY_LOG_EVENT_TYPE.CLIENT_ANNOTATION_DRAGGED, this.state.activity.activity_key, null, this.getActivityUser().id, this.props.activityContext, data.annotation != null ? data.annotation : void 0);
        case "page-rendered":
          if (!this.previewIsReady) {
            this.previewIsReady = true;
            if (this._isPreviewAndCommentsReady()) {
              this.onPreviewAndCommentsReady();
            }
            this._previewLoaded();
          }
          return this.redrawAllAnnotations(data != null ? data.page : void 0);
        case "annotation-ui-click":
          commentActivity = data.commentActivity;
          commentMetadata = (ref = data.commentActivity) != null ? (ref1 = ref.comment) != null ? ref1.comment_metadata : void 0 : void 0;
          commentRevision = (ref2 = data.commentActivity) != null ? (ref3 = ref2.comment) != null ? (ref4 = ref3.comment_metadata) != null ? ref4.revision : void 0 : void 0 : void 0;
          if ((commentRevision != null) && !this.fileViewerState.isCurrentlyAtRevision(commentRevision)) {
            this.showAnnotationWithPreview(commentActivity, commentMetadata);
          } else {
            this.showAnnotationCommentsBubble(data);
            this.highlightComment(data);
          }
          return FileActivityClientLogger.log_annotation_event(Constants.FILE_ACTIVITY_LOG_EVENT_TYPE.CLIENT_ANNOTATION_UI_CLICKED, this.state.activity.activity_key, (ref5 = data.commentActivity) != null ? ref5.activity_key : void 0, this.getActivityUser().id, this.props.activityContext);
        case "annotation-ui-enter":
          this.showAnnotationCommentsBubble(data);
          return FileActivityClientLogger.log_annotation_event(Constants.FILE_ACTIVITY_LOG_EVENT_TYPE.CLIENT_ANNOTATION_UI_HOVER, this.state.activity.activity_key, (ref6 = data.commentActivity) != null ? ref6.activity_key : void 0, this.getActivityUser().id, this.props.activityContext);
        case "annotation-ui-leave":
          clearTimeout(this.annotationCommentsListUIBubbleTimer);
          return this.annotationCommentsListUIBubbleTimer = setTimeout((function(_this) {
            return function() {
              return _this.hideAnnotationCommentsBubble();
            };
          })(this), 200);
        case "scale-change":
          this.hideAnnotationBubble();
          return this.hideAnnotationCommentsBubble();
        case "scroll":
          this.hideAnnotationBubble();
          this.hideAnnotationCommentsBubble();
          clearTimeout(this.annotationBubbleTimer);
          if (data) {
            return this.annotationBubbleTimer = setTimeout((function(_this) {
              return function() {
                return _this.placeAnnotationBubble(data);
              };
            })(this), 150);
          }
          break;
        case "on-keydown":
          keyPressed = data.keyCode || data.which || data.charCode;
          if (keyPressed === KeyCode.ESC && ((ref7 = this.annotationBubble) != null ? ref7.props.showBubble : void 0)) {
            this.hideAnnotationBubble();
            return this.hideAnnotation();
          }
          break;
        case "reset-file-feedback-ui":
          this.previewIsReady = false;
          this.hideAnnotationBubble();
          return this.hideAnnotationCommentsBubble();
      }
    },
    onSwitchToLatestRevision: function() {
      this.switchRevision(this.fileViewerState.getLatestRevision());
      return this.removeSwitchToLatestRevisionUI();
    },
    setSwitchToLatestRevisionUI: function(revision) {
      var ref;
      this.setState({
        isCommentInputDisabled: true
      });
      return (ref = this.switchRevisionUI) != null ? ref.setProps({
        showSwitchRevisionUI: true,
        revision: revision
      }) : void 0;
    },
    removeSwitchToLatestRevisionUI: function() {
      var ref;
      this.setState({
        isCommentInputDisabled: false
      });
      return (ref = this.switchRevisionUI) != null ? ref.setProps({
        showSwitchRevisionUI: false
      }) : void 0;
    },
    switchRevision: function(revision, commentActivity, callback) {
      var base, base1, shouldEnableAnnotationCreation;
      if ((revision != null) && !this.fileViewerState.isCurrentlyAtRevision(revision)) {
        this.removeAllAnnotations();
        this.previewIsReady = false;
        this.annotationBubble = null;
        this.annotationCommentsListUIBubble = null;
        this.fileViewerState.setCurrentRevision(revision);
        shouldEnableAnnotationCreation = this.fileViewerState.isCurrentlyAtLatestRevision() && this._isAnnotationCreationEnabled();
        if (this.props.activityContext === ActivityContext.BROWSE_FILE_VIEWER) {
          if (typeof (base = this.props).switchPreview === "function") {
            base.switchPreview(revision.preview_link, revision.direct_blockserver_link, shouldEnableAnnotationCreation, callback);
          }
        } else if (this.props.activityContext === ActivityContext.SHARED_LINK_VIEW) {
          if (typeof (base1 = this.props).switchPreview === "function") {
            base1.switchPreview(revision.revision_id, shouldEnableAnnotationCreation, callback, revision.preview_link, commentActivity);
          }
        }
        if (this.fileViewerState.isOldRevision(revision)) {
          return this.setSwitchToLatestRevisionUI(revision);
        } else {
          return this.removeSwitchToLatestRevisionUI();
        }
      } else {
        if (callback) {
          return callback();
        }
      }
    },
    showAnnotationWithPreview: function(commentActivity, commentMetadata) {
      var annotation, annotationPage;
      if (this.fileViewerInterfaceController) {
        annotation = Annotation.createAnnotationFromDict(commentMetadata.annotation);
        annotationPage = annotation.getFirstPdfPage();
        if (!this.fileViewerState.isCurrentlyAtRevision(commentMetadata.revision)) {
          this.switchRevision(commentMetadata.revision, commentActivity, (function(_this) {
            return function() {
              _this._prepareFileViewerInterfaceController(_this.props.activityContext);
              return _this._previewLoadedCallback = function() {
                return _this._scrollToAnnotationInPreview(annotationPage, commentActivity);
              };
            };
          })(this));
        } else {
          this._scrollToAnnotationInPreview(annotationPage, commentActivity);
        }
      }
      return FileActivityClientLogger.log_annotation_event(Constants.FILE_ACTIVITY_LOG_EVENT_TYPE.CLIENT_ANNOTATION_BUTTON_CLICKED, this.state.activity.activity_key, commentMetadata.activity_key, this.getActivityUser().id, this.props.activityContext, commentMetadata.annotation);
    },
    _addRevisionToCommentMetadata: function(commentMetadata) {
      var currentRevision;
      if (commentMetadata == null) {
        commentMetadata = {};
      }
      currentRevision = this.fileViewerState.getCurrentRevision();
      if (currentRevision) {
        commentMetadata.revision = currentRevision;
      }
      return commentMetadata;
    },
    _prepareCommentMetadataWithAnnotation: function(annotation) {
      var commentMetadata;
      commentMetadata = {
        annotation: annotation.toMetadataDict()
      };
      return this._addRevisionToCommentMetadata(commentMetadata);
    },
    onDeleteCommentFromAnnotationBubble: function(commentActivity) {
      this.onDeleteComment(commentActivity);
      this.hideAnnotationCommentsBubble();
      return this.fileViewerInterfaceController.dispatchEvent("remove-annotation", {
        commentActivity: commentActivity
      });
    },
    onResolveCommentFromAnnotationBubble: function(commentActivity, resolved) {
      return this.onResolveComment(commentActivity, resolved);
    },
    onAddCommentFromAnnotationBubble: function(text, annotation) {
      this.hideAnnotationBubble();
      return this.onAddComment(text, this._prepareCommentMetadataWithAnnotation(annotation));
    },
    onCancelCommentFromAnnotationBubble: function() {
      this.hideAnnotationBubble();
      return this.hideAnnotation();
    },
    onLikeCommentFromAnnotationBubble: function(commentActivity) {
      return this.onLikeComment(commentActivity);
    },
    onAddCommentFromSticker: function(sticker_id) {
      var metadata;
      metadata = {
        stickers: {
          id: sticker_id
        }
      };
      return this.onAddComment('', this._addRevisionToCommentMetadata(metadata));
    },
    onAddCommentFromList: function(text, commentMetadata, commentActivity) {
      if (commentMetadata == null) {
        commentMetadata = {};
      }
      if (commentActivity == null) {
        commentActivity = null;
      }
      return this.onAddComment(text, commentMetadata, commentActivity);
    },
    onDeleteCommentFromList: function(commentActivity) {
      return this.onDeleteComment(commentActivity);
    },
    onResolveCommentFromList: function(commentActivity, resolved) {
      return this.onResolveComment(commentActivity, resolved);
    },
    onLikeCommentFromList: function(commentActivity) {
      return this.onLikeComment(commentActivity);
    },
    onAddComment: function(text, commentMetadata, commentActivity) {
      var email_verification, onError, onSuccess;
      if (commentActivity == null) {
        commentActivity = null;
      }
      if (!this.getActivityUser().is_signed_in) {
        this.modals.show_sign_in_modal(CommentsSharedLinkSignupModals.POST_COMMENT_VARIANT);
        return FileActivityClientLogger.log_event(Constants.FILE_ACTIVITY_LOG_EVENT_TYPE.CLIENT_SIGN_UP_MODAL, this.state.activity.activity_key, null, Constants.FILE_ACTIVITY_LOG_CLIENT_ORIGIN_TYPE.POST_BUTTON);
      } else if (this.getActivityUser().is_email_verified) {
        text = $j.trim(text);
        onSuccess = (function(_this) {
          return function(activity) {
            _this.setState({
              isNewCommentLoading: false,
              activity: $u.clone(activity)
            }, function() {
              var ref, ref1;
              if (commentActivity != null) {
                _this.hideAnnotationCommentsBubble();
                return (ref = _this.annotationCommentsListUIBubble) != null ? ref.setProps({
                  commentActivity: commentActivity
                }) : void 0;
              } else {
                if ((ref1 = _this.refs.commentListUI) != null) {
                  ref1.animateScrollToBottom();
                }
                return _this.redrawAllAnnotations();
              }
            });
            return _this.hideAnnotation();
          };
        })(this);
        onError = (function(_this) {
          return function(response) {
            var error_text;
            error_text = response.error_text || _("An error occurred while commenting.");
            Notify.error(error_text);
            return _this.setState({
              isNewCommentLoading: false
            });
          };
        })(this);
        this.state.contextActivityStore.add_comment(this.state.activity, this.getActivityUser(), text, commentMetadata, commentActivity, onSuccess, onError);
        if (commentActivity == null) {
          this.setState({
            isNewCommentLoading: true
          }, (function(_this) {
            return function() {
              var ref;
              return (ref = _this.refs.commentListUI) != null ? ref.scrollToBottom() : void 0;
            };
          })(this));
        }
        this.setState({
          isSender: true
        });
        return this.contactSearchLogger.log_records(this.getActivityUser().id, false);
      } else {
        email_verification = EmailVerification.get_for_user(this.getActivityUser());
        EmailVerification.set_should_use_simple_ui(this.props.shouldUseSimpleModals);
        return email_verification.show_verify_modal(null, EmailVerificationReasons.ADD_COMMENT);
      }
    },
    onDeleteComment: function(commentActivity) {
      var onError, onSuccess;
      onError = (function(_this) {
        return function(response) {
          Notify.error(_("An error occurred while deleting the comment."));
          return _this.forceUpdate();
        };
      })(this);
      onSuccess = (function(_this) {
        return function(response) {
          Notify.success(_("Comment deleted"), 2);
          _this.fileViewerInterfaceController.dispatchEvent("remove-annotation", {
            commentActivity: commentActivity
          });
          _this.forceUpdate();
        };
      })(this);
      return this.state.contextActivityStore.delete_comment(this.state.activity, this.getActivityUser(), commentActivity.activity_key, onSuccess, onError);
    },
    onResolveComment: function(commentActivity, resolved) {
      var onError, onSuccess;
      onSuccess = (function(_this) {
        return function(response) {};
      })(this);
      onError = (function(_this) {
        return function(response) {
          if (resolved) {
            Notify.error(_("An error occurred while setting the comment to resolved."));
          } else {
            Notify.error(_("An error occurred while setting the comment to not resolved."));
          }
          return _this._onResolveUpdateUI(commentActivity, !resolved);
        };
      })(this);
      this.state.contextActivityStore.update_resolved(commentActivity, this.getActivityUser(), resolved, onSuccess, onError);
      return this._onResolveUpdateUI(commentActivity, resolved);
    },
    _onResolveUpdateUI: function(commentActivity, resolved) {
      var activity, ca, i, len, ref, ref1, ref2, ref3;
      if (((ref = this.annotationCommentsListUIBubble) != null ? (ref1 = ref.props.commentActivity) != null ? ref1.activity_key : void 0 : void 0) === commentActivity.activity_key) {
        if (resolved && !this.state.showResolvedComments) {
          this.hideAnnotationCommentsBubble();
        } else {
          commentActivity = $u.clone(commentActivity);
          commentActivity.comment.resolved = resolved;
          if ((ref2 = this.annotationCommentsListUIBubble) != null) {
            ref2.setProps({
              commentActivity: commentActivity
            });
          }
        }
      }
      activity = $u.clone(this.state.activity);
      ref3 = activity.comment_activities;
      for (i = 0, len = ref3.length; i < len; i++) {
        ca = ref3[i];
        if (ca.activity_key === commentActivity.activity_key) {
          ca.comment.resolved = resolved;
        }
      }
      return this.setState({
        activity: activity
      });
    },
    onLikeComment: function(commentActivity) {
      if (!this.getActivityUser().is_signed_in) {
        ActivityLocalStorage.set_store("like", this.state.activity.activity_key, commentActivity.activity_key);
        this.modals.show_sign_in_modal(CommentsSharedLinkSignupModals.LIKE_COMMENT_VARIANT);
        return FileActivityClientLogger.log_event(Constants.FILE_ACTIVITY_LOG_EVENT_TYPE.CLIENT_SIGN_UP_MODAL, this.state.activity.activity_key, commentActivity.activity_key, Constants.FILE_ACTIVITY_LOG_CLIENT_ORIGIN_TYPE.LIKE_BUTTON);
      }
    },
    onToggleShowResolvedComments: function() {
      return this.setState({
        showResolvedComments: !this.state.showResolvedComments
      });
    },
    _isUserSubscribed: function() {
      var i, len, ref, user;
      if (this.state.activity && this.state.activity.users_to_notify) {
        ref = this.state.activity.users_to_notify;
        for (i = 0, len = ref.length; i < len; i++) {
          user = ref[i];
          if (user.id === this.getActivityUser().id) {
            return true;
          }
        }
      }
      return false;
    },
    toggleFeedbackForViewer: function() {
      var onFailureMessage, onSuccessMessage, willSubscribe;
      if (!this.getActivityUser().is_signed_in) {
        ActivityLocalStorage.set_store("subscribe", this.state.activity.activity_key);
        this.modals.show_sign_in_modal(CommentsSharedLinkSignupModals.SUBSCRIBE_VARIANT);
        return FileActivityClientLogger.log_event(Constants.FILE_ACTIVITY_LOG_EVENT_TYPE.CLIENT_SIGN_UP_MODAL, this.state.activity.activity_key, null, Constants.FILE_ACTIVITY_LOG_CLIENT_ORIGIN_TYPE.SUBSCRIBE_BUTTON);
      } else {
        willSubscribe = !this._isUserSubscribed();
        onSuccessMessage = willSubscribe ? _("You have been subscribed.") : _("You have been unsubscribed.");
        onFailureMessage = willSubscribe ? _("We failed to subscribe you.") : _("We failed to unsubscribe you.");
        return this._toggleSubscribe(null, willSubscribe, onSuccessMessage, onFailureMessage);
      }
    },
    onFacepileContactAdded: function($suggestion) {
      var dbx_account_id, identifier, name, onFailureMessage, onSuccessMessage, photo_url, ref, u, user;
      if ($suggestion != null) {
        name = $suggestion.data('name');
        identifier = $suggestion.data('identifier');
        photo_url = $suggestion.data('photo-url');
        dbx_account_id = $suggestion.data('dbx-account-id');
        user = new ActivityUser({
          id: dbx_account_id,
          display_name: name,
          email: identifier,
          photo_url: photo_url,
          photo_circle_url: photo_url
        });
        if (ref = user.id, indexOf.call((function() {
          var i, len, ref1, results;
          ref1 = this.state.activity.users_to_notify;
          results = [];
          for (i = 0, len = ref1.length; i < len; i++) {
            u = ref1[i];
            results.push(u.id);
          }
          return results;
        }).call(this), ref) >= 0) {
          Notify.error(_("User has already been subscribed!"));
          return;
        }
        onSuccessMessage = _("User subscribed to comments.");
        onFailureMessage = _("An error occurred while subscribing user.");
        return this._toggleSubscribe(user, true, onSuccessMessage, onFailureMessage);
      }
    },
    _toggleSubscribe: function(userToNotify, willSubscribe, onSuccessMessage, onErrorMessage) {
      var email_verification, onActivityUpdate, onError, onSuccess, ref;
      if (!this.getActivityUser().is_email_verified && willSubscribe) {
        ActivityLocalStorage.set_store("subscribe", (ref = this.state.activity) != null ? ref.activity_key : void 0);
        email_verification = EmailVerification.get_for_user(this.getActivityUser());
        EmailVerification.set_should_use_simple_ui(this.props.shouldUseSimpleModals);
        return email_verification.show_verify_modal(null, EmailVerificationReasons.SUBSCRIBE_TO_COMMENTS);
      } else {
        onActivityUpdate = (function(_this) {
          return function(activity) {
            Notify.success(onSuccessMessage);
            return _this.onSubscribeUpdated(activity);
          };
        })(this);
        onSuccess = (function(_this) {
          return function(activity) {
            return _this.onSubscribeUpdated(activity);
          };
        })(this);
        onError = (function(_this) {
          return function(activity) {
            Notify.error(onErrorMessage);
            return _this.onSubscribeUpdated(activity);
          };
        })(this);
        return this.state.contextActivityStore.update_subscribe(this.state.activity, this.getActivityUser(), willSubscribe, userToNotify, onActivityUpdate, onSuccess, onError);
      }
    },
    _verifyAfterSignUpCallback: function() {
      var email_verification;
      email_verification = EmailVerification.get_for_user(this.getActivityUser());
      EmailVerification.set_should_use_simple_ui(this.props.shouldUseSimpleModals);
      email_verification.send_email(EmailVerificationReasons.ADD_COMMENT, function() {});
      return email_verification.show_resend_verify_modal(EmailVerificationReasons.ADD_COMMENT);
    },
    onAnnotationButtonMouseUp: function(commentActivity, commentMetadata) {
      return this.showAnnotationWithPreview(commentActivity, commentMetadata);
    },
    _scrollToAnnotationInPreview: function(page, commentActivity) {
      return this.fileViewerInterfaceController.dispatchEvent("scroll-to-annotation", {
        page: page,
        commentActivity: commentActivity
      });
    },
    resetToBlankState: function() {
      if ($j(".blank-state").length === 0) {
        $j(".comments-holder .comment-list-facepile:visible").hide();
        $j(".comments-holder .comment-activity:visible").hide();
        $j(".comments-holder .comment-field:visible").hide();
        return true;
      }
      return false;
    },
    showFeedbackModal: function(event) {
      var input_html;
      if (event != null) {
        event.preventDefault();
      }
      input_html = "<div class=\"text-input comment-feedback-input\"> <div class=\"text-input-wrapper\"> <textarea id=\"comments-feedback-input\" placeholder=\"Let us know how we can improve commenting in Dropbox.\" ></textarea> </div> </div>";
      return SimpleModal.show({
        title_text: _("Help us improve comments"),
        body_html: input_html,
        cancel_text: _("Cancel"),
        confirm_text: _("Submit Feedback"),
        confirm_callback: (function(_this) {
          return function() {
            var feedback_text;
            feedback_text = $j("#comments-feedback-input").val();
            return _this.state.contextActivityStore.submit_product_feedback(_this.getActivityUser(), feedback_text, function() {
              return Notify.success(_("Thank you! Your feedback will help improve Dropbox."));
            }, function() {
              return Notify.error(_("There was an error submitting your feedback."));
            });
          };
        })(this)
      });
    },
    getActivityUser: function() {
      var viewer;
      viewer = Viewer.get_viewer();
      if (this.props.userId) {
        return new ActivityUser(viewer.get_user_by_id(this.props.userId));
      } else if (viewer.work_user || viewer.personal_user) {
        return new ActivityUser(viewer.work_user || viewer.personal_user);
      } else if (!viewer.is_signed_in) {
        return new ActivityUser();
      }
    },
    setLockedIcon: function() {
      return this.setState({
        icon: "s_comments_locked"
      });
    },
    setUnlockedIcon: function() {
      return this.setState({
        icon: "s_comments_unlocked"
      });
    },
    disable: function() {
      return this.setState({
        enabled: false
      });
    },
    enable: function() {
      this.setState({
        enabled: true
      });
      return this.forceUpdate();
    },
    turnOffComments: function() {
      var base;
      this.setState({
        comments_on: false,
        icon: "s_comments_locked"
      });
      return typeof (base = this.props).hideToggledCallback === "function" ? base.hideToggledCallback(false) : void 0;
    },
    turnOnComments: function(event) {
      var base;
      if (event != null) {
        event.preventDefault();
      }
      if (this.isMounted()) {
        this.setState({
          comments_on: true
        });
        return typeof (base = this.props).hideToggledCallback === "function" ? base.hideToggledCallback(true) : void 0;
      }
    },
    turnOnFeedback: function() {
      return this.state.contextActivityStore.update_feedback_setting($u.clone(this.state.activity), this.getActivityUser(), false, (function(_this) {
        return function(updated_activity) {
          return _this.setState({
            activity: updated_activity
          });
        };
      })(this));
    },
    turnOffFeedback: function() {
      this.state.contextActivityStore.update_feedback_setting($u.clone(this.state.activity), this.getActivityUser(), true, (function(_this) {
        return function(updated_activity) {
          return _this.setState({
            activity: updated_activity
          });
        };
      })(this));
      return this.turnOffComments();
    },
    onSubscribeUpdated: function(activity) {
      return this.setState({
        activity: activity
      });
    },
    hide: function(event) {
      var base;
      if (event != null) {
        event.preventDefault();
      }
      this.setState({
        visible: false
      });
      if (this.state.activity) {
        FileActivityClientLogger.log_event(Constants.FILE_ACTIVITY_LOG_EVENT_TYPE.CLIENT_COMMENTS_HIDDEN, this.state.activity.activity_key, null, null, this.getActivityUser().id, this.props.activityContext);
      }
      return typeof (base = this.props).hideToggledCallback === "function" ? base.hideToggledCallback(false) : void 0;
    },
    show: function(event) {
      var base;
      if (event != null) {
        event.preventDefault();
      }
      this.setState({
        visible: true
      });
      if (this.state.activity) {
        FileActivityClientLogger.log_event(Constants.FILE_ACTIVITY_LOG_EVENT_TYPE.CLIENT_COMMENTS_SHOWN, this.state.activity.activity_key, null, null, this.getActivityUser().id, this.props.activityContext);
      }
      return typeof (base = this.props).hideToggledCallback === "function" ? base.hideToggledCallback(true) : void 0;
    },
    fitToHeight: function(height) {
      if (this.state.height !== height) {
        return this.setState({
          height: height
        });
      }
    },
    _refreshWidth: function() {
      var base, width;
      if ($j(".video-js").length) {
        $j(".video-js").css("width", "100%");
      }
      if (this.state.enabled) {
        width = $j(this.getDOMNode()).width();
      } else {
        width = 0;
      }
      return typeof (base = this.props).previewWidthCallback === "function" ? base.previewWidthCallback(width) : void 0;
    },
    _shouldFetchActivity: function() {
      var result;
      result = this.props.activityContext && this.props.activityContextData && !this.state.isFetchingActivity;
      return this.props.activityContext && this.props.activityContextData && !this.state.isFetchingActivity;
    },
    _onActivitySuccessfullyFetched: function(activity) {
      if (this.isMounted()) {
        if (activity.feedback_off) {
          this.turnOffComments();
        } else {
          this.turnOnComments();
        }
        this.fileViewerState.setFileActivity(activity);
        this.enable();
        return this.setState({
          activity: activity,
          isFetchingActivity: false
        }, (function(_this) {
          return function() {
            if (!activity.feedback_off && _this.modals) {
              _this.modals.set_activity_key(activity.activity_key);
            }
            if (_this._isPreviewAndCommentsReady()) {
              _this.onPreviewAndCommentsReady();
            }
            _this._prepareSwitchRevisionUI();
            return _this._markAllCommentsSeen();
          };
        })(this));
      }
    },
    _fetchActivity: function(onSuccess) {
      var error_callback, onActivitySuccessfullyFetched, success_callback;
      onActivitySuccessfullyFetched = (function(_this) {
        return function(activity) {
          _this._onActivitySuccessfullyFetched(activity);
          if (_this.isMounted() && _this.getActivityUser().is_signed_in) {
            return _this._startLiveUpdate();
          }
        };
      })(this);
      error_callback = (function(_this) {
        return function(xhr, status, error_string) {
          _this.disable();
          return _this.setState({
            isFetchingActivity: false
          });
        };
      })(this);
      storage.SessionStorage.set('reload-timestamp', new Date().getTime());
      success_callback = (function(_this) {
        return function(activity, bolt_data) {
          if (_this.isMounted()) {
            _this._bolt_data = bolt_data;
          }
          onActivitySuccessfullyFetched(activity);
          return typeof onSuccess === "function" ? onSuccess(activity) : void 0;
        };
      })(this);
      this.state.contextActivityStore.fetch_activity_and_bolt_data(this.getActivityUser(), success_callback, error_callback, this.props.oref, true);
      return this.setState({
        isFetchingActivity: true
      });
    },
    _hasLoaded: function() {
      return this.state.activity != null;
    },
    _startLiveUpdate: function() {
      var channel_states, update_activity;
      update_activity = (function(_this) {
        return function(new_activity, action_type) {
          if (action_type == null) {
            action_type = null;
          }
          if (!_this.isMounted()) {
            return;
          }
          if (new_activity.feedback_off) {
            _this.turnOffComments();
            return;
          }
          _this.turnOnComments();
          _this.setState({
            activity: new_activity
          });
          _this._markAllCommentsSeen();
          return _this.onNewActivity(action_type);
        };
      })(this);
      this._bolt_get_channel_states = function() {
        var ref, ref1, revision, token, unique_id;
        unique_id = this.state.activity.activity_key;
        revision = (ref = this._bolt_data) != null ? ref.revision : void 0;
        token = (ref1 = this._bolt_data) != null ? ref1.token : void 0;
        return [new Bolt.SignedChannelState('file_activity', unique_id, revision, token)];
      };
      this._bolt_cb = (function(_this) {
        return function(channel_states) {
          var success_callback;
          if (!((channel_states != null ? channel_states.length : void 0) === 1 && channel_states[0].unique_id === _this.state.activity.activity_key)) {
            return;
          }
          success_callback = function(activity, bolt_data) {
            var ref;
            if (!_this.isMounted()) {
              return;
            }
            _this._bolt_data = bolt_data;
            channel_states = _this._bolt_get_channel_states();
            if ((ref = _this._bolt_client) != null) {
              ref.update_states(channel_states);
            }
            return update_activity(activity, bolt_data.action_type);
          };
          storage.SessionStorage.set('reload-timestamp', new Date().getTime());
          return _this.state.contextActivityStore.fetch_activity_and_bolt_data(_this.getActivityUser(), success_callback, null);
        };
      })(this);
      channel_states = this._bolt_get_channel_states();
      this._bolt_client = new Bolt.BoltClient(channel_states, this._bolt_cb, this._fetchActivity);
      return this._bolt_client.start();
    },
    _stopLiveUpdate: function() {
      var ref;
      if ((ref = this._bolt_client) != null) {
        ref.unsubscribe();
      }
      return this._bolt_client = null;
    },
    onNewActivity: function(action_type) {
      var ref;
      this.setState({
        isNewCommentLoading: false
      });
      if (!((ref = this.refs.commentListUI) != null ? ref.isScrolledToBottom() : void 0) && !this.state.isSender && action_type === Constants.FILE_ACTIVITY_ACTION_TYPE.NEW_COMMENT) {
        this.setState({
          showNewComment: true
        });
      }
      return this.setState({
        isSender: false
      });
    },
    checkCommentListScroll: function() {
      var isScrolledToBottom, showBottomBar;
      isScrolledToBottom = this.refs.commentListUI.isScrolledToBottom();
      showBottomBar = !isScrolledToBottom;
      if (showBottomBar !== this.state.showBottomBar) {
        this.setState({
          showBottomBar: showBottomBar
        });
      }
      if (isScrolledToBottom && this.state.showNewComment) {
        return this.setState({
          showNewComment: false
        });
      }
    },
    onShowNewComment: function() {
      this.refs.commentListUI.animateScrollToBottom();
      return this.setState({
        showNewComment: false
      });
    },
    _markAllCommentsSeen: function() {
      var lastCommentActivity, ref, successCallback;
      if (!this.getActivityUser().is_signed_in || !this.state.comments_on) {
        return;
      }
      successCallback = (function(_this) {
        return function(resp) {
          return _this.notifyActivityLoaded(_this.state.activity);
        };
      })(this);
      ref = this.state.activity.comment_activities, lastCommentActivity = ref[ref.length - 1];
      if (lastCommentActivity) {
        return this.state.contextActivityStore.mark_comments_seen(this.state.activity, this.getActivityUser(), lastCommentActivity.activity_key, successCallback);
      }
    },
    render: function() {
      var base, comments_section_height, feedback_ui_classes, shouldShowCommentsFeedbackButton, show_likes_section, user;
      feedback_ui_classes = React.addons.classSet({
        "file-feedback": true,
        "hidden": !this.state.enabled
      });
      if (!this.state.enabled) {
        if (typeof (base = this.props).previewWidthCallback === "function") {
          base.previewWidthCallback(0);
        }
      }
      user = this.getActivityUser();
      shouldShowCommentsFeedbackButton = user.is_signed_in && (GandalfUtil.getGandalfRule("comments-web-feedback") || GandalfUtil.getGandalfRule("inline-comments-beta"));
      show_likes_section = this.props.activityContext && this.props.activityContextData && this.props.photoLikesVariant !== "CONTROL";
      comments_section_height = this.state.height;
      if (show_likes_section) {
        comments_section_height -= LIKES_SECTION_HEIGHT;
      }
      if (shouldShowCommentsFeedbackButton) {
        comments_section_height -= FEEDBACK_HEIGHT;
      }
      if (this.state.isOffline) {
        comments_section_height -= OFFLINE_BANNER_HEIGHT;
      }
      if ((this.state.visible && this.state.comments_on) || !this.props.canCollapse) {
        return d.div({
          id: this.props.feedbackId,
          ref: "fileFeedbackUI",
          className: feedback_ui_classes,
          tabIndex: "-1",
          style: {
            height: this.state.height
          }
        }, show_likes_section ? FileFeedbackLikesSection({
          contextActivityStore: this.state.contextActivityStore,
          activity: this.state.activity,
          height: LIKES_SECTION_HEIGHT,
          user: user
        }) : void 0, this.props.activityContext && this.props.activityContextData ? d.div({
          className: "comments-and-feedback"
        }, this.state.isOffline ? d.div({
          className: "comments-offline-banner"
        }, d.div({
          className: "comments-offline-banner-inner"
        }, R_({}, "No Internet Connection"))) : void 0, CommentListUI({
          key: "comment_list_" + this.props.activityContextData,
          ref: "commentListUI",
          activity: this.state.activity,
          contextActivityStore: this.state.contextActivityStore,
          fileViewerInterfaceController: this.fileViewerInterfaceController,
          height: comments_section_height,
          user: user,
          fileViewerState: this.fileViewerState,
          contactSearchLogger: this.contactSearchLogger,
          enableFacepile: GandalfUtil.isGandalfInVariant("dw-comments-notify-facepile", "FACEPILE"),
          enableNoNotifyHint: GandalfUtil.isGandalfInVariant("dw-comments-no-notify-hint", "CONTROL"),
          forceNullStateLoadingState: this.props.forceNullStateLoadingState,
          isNewCommentLoading: this.state.isNewCommentLoading,
          isSender: this.state.isSender,
          isUserSubscribed: this._isUserSubscribed(),
          shouldAutoLinkify: this.props.shouldAutoLinkify,
          shouldInitiallyFocusInput: this.props.shouldInitiallyFocusInput,
          showNewComment: this.state.showNewComment,
          showResolvedComments: this.state.showResolvedComments,
          isCommentInputDisabled: this.state.isCommentInputDisabled,
          enableImport: this.props.enableImport,
          shouldUseSimpleModals: this.props.shouldUseSimpleModals,
          shouldHidePhotoAvatars: this.props.shouldHidePhotoAvatars,
          isThreadingEnabled: this._isThreadingEnabled(),
          isTinyAnnotationUIEnabled: this.isTinyAnnotationUIEnabled,
          isVisibleAtMentions: GandalfUtil.isGandalfInVariant("dw-comments-visible-at-mentions", "CONTROL"),
          isOffline: this.state.isOffline,
          shouldAnnotationButtonUseThumbnailUrls: this.props.shouldAnnotationButtonUseThumbnailUrls,
          shouldShowAnnotationUIOnImages: this.shouldShowAnnotationUIOnImages,
          onAddCommentFromList: this.onAddCommentFromList,
          onAddSticker: this.onAddCommentFromSticker,
          onAnnotationButtonMouseUp: this.onAnnotationButtonMouseUp,
          onDeleteComment: this.onDeleteCommentFromList,
          onFacepileContactAdded: this.onFacepileContactAdded,
          onHideCommentsPane: this.hide,
          onInputBlur: this.props.onInputBlur,
          onInputFocus: this.props.onInputFocus,
          onLikeComment: this.onLikeCommentFromList,
          onUpdateResolve: this.onResolveCommentFromList,
          checkScroll: this.checkCommentListScroll,
          onShowNewComment: this.onShowNewComment,
          onSubscribeUpdated: this.onSubscribeUpdated,
          onToggleShowResolvedComments: this.onToggleShowResolvedComments,
          shouldShowHideButton: this.props.canCollapse,
          toggleFeedbackForViewer: this.toggleFeedbackForViewer,
          turnOffFeedbackCallback: this.turnOffFeedback,
          turnOnFeedbackCallback: this.turnOnFeedback,
          verifyAfterSignUpCallback: this._verifyAfterSignUpCallback
        }), shouldShowCommentsFeedbackButton ? d.div({
          className: "comments-feedback-link",
          style: {
            height: FEEDBACK_HEIGHT
          }
        }, d.div({
          className: "comments-feedback-link-inner"
        }, d.a({
          onMouseUp: this.showFeedbackModal
        }, R_({}, "Help us improve comments")))) : void 0) : void 0);
      } else if (this.state.comments_on && !this.state.visible) {
        return d.div({
          id: this.props.feedbackId,
          className: "hidden-comments",
          style: {
            height: this.state.height
          }
        }, d.div({
          className: "show-button " + this.props.showButtonColor,
          onMouseDown: this.show
        }, d.div({
          className: "show-button-sprite"
        }, Sprite({
          group: "web",
          name: "s_show_comments_grey"
        }))));
      } else {
        if (this._hasLoaded() && this.state.activity.can_edit_feedback) {
          return d.div({
            id: this.props.feedbackId,
            className: "hidden-comments",
            style: {
              height: this.state.height
            },
            onMouseOver: this.setUnlockedIcon,
            onMouseOut: this.setLockedIcon
          }, d.div({
            className: "show-button " + this.props.showButtonColor,
            onMouseDown: this.turnOnComments
          }, d.div({
            className: "show-button-sprite"
          }, Sprite({
            group: "web",
            name: this.state.icon
          }))));
        } else {
          return d.div({
            id: this.props.feedbackId,
            className: "hidden"
          });
        }
      }
    }
  });
  return {
    FileFeedbackUIClass: FileFeedbackUIClass
  };
});

//# sourceMappingURL=file_comments_pane.js.map
